The backend consists of small isolated microservices. To keep code duplication to a minimum and ensure a basic infrastrcture all services can use and rely on, there are some services that are deployed globally:
- API Gateway
- API Gateway ID sharing server
- Templates and functions for deployment
- Default Lambda handler for OPTIONS methods

## Infrastructure for all microservices

#### API Gateway
The API Gateway serves as the connection between the backend services and the frontend. The frontend must be able to make call to a URL to receive HTTP responses from the backend. The backend services must be able to register their functions on a given URL path. This is provided by the API Gateway. The service [apig-main](./apig-main/) creates an API Gateway, see the README for more information.

#### API Gateway ID sharing server
In order to make the generated URL available to the frontend service, a small Flask is deployed. Its sole job is to provide the URL generated by apig-main to the frontend. The frontend can then call the server and receives the URL on which it can make subsequent calls.  
This setup is neccesary since we can not provide a static URL which would require various pro features of localstack.

#### Templates
The folder [template-microservice](./template-microservice/) contains a template for a microservice with all neccesary configuraitons, labmda handlers, a deploy scirpt and a dockerfile. It also contains the following files that are used by all new microservice:
- [deploy_utils.py](./template-microservice/deploy_utils.py)
- [deploy.py](./template-microservice/deploy.py)

Those two scripts take care of the deployment of the specified resources (DynamoDB tables, Lambda functions, API routes etc).

#### Default Lambda handler for OPTIONS methods
During deployment we ran into CORS errors which blocked calls from the frontend to the backend. To enable CORS with API Gateway, each route must implement an OPTIONS method which sends the appropirate headers in a prefetch. (https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-cors.html). To reduce code duplication, the service [options_lambda_function](./options_lambda_function/) deploys a lambda handler which simply returns a 200 message and the appropirate CORS headers. This function is deployed once and used by all other microservices for each integrated route.

#### Tests
The backend tests are run in a CI pipeline with Github Actions. See the [github actions folder](../.github/workflows/code_quality.yml) for the concrete command and workflow. The produced [test report](../.qodana/code-coverage/) is updated and uploaded in the repo
If you want to run the test manually and generate an inline coverage report, run this from a terminal in the root directory:
`coverage run -m pytest && coverage report -m`

###### Test limitations
The current moto3 mocking framework for AWS does not support our API Gateway integration (AWS_PROXY), hence a proper intergation test with a mocked API Gateway with localstack is currently not possible. For more information see http://docs.getmoto.org/en/latest/docs/services/apigateway.html.


## Microservice structure
A microservice uses the templates and utils from the `template-microservice` folder as much as possible to standardize deployment and reduce duplication.  
Each microservice contains a `config` folder where the following files are located. The `deploy.py` script then refers to those configurations to deploy the desired microservice.

- `db_schema.json` A list of Dynamo table specifications that will be created upon deployment. It defines the name of the table and the keys of the table.
- `mock_data.json` If desired, any mock data that will be injected into the tables upon deployment. Can be empty.
- `request_models.json` Named request models in JSON schema draft 4, following the AWS specifications. Those schemas can be used to specify a valid body in the API calls made to the respective routes and lambda integrations. This is helpful to ensure the validity of the data coming from the frontend. The `title` attribute is then used in `resources_to_create.json` to specify which route and lambda integartion uses (if any) which request model.
- `request_validators.json` This is part of the validation, specifying which part of the request made to the API Gateway should be checked. In this project, the `bodyOnly` validator is used. This means headers and other parameters of the request are not validated, only the body of a request.
- `resources_to_create.json` A nested json of routes to create for the microservice. The nested levels build up the route. The following example would build the following to routes:  
    - `GET /template-microservice` calling the lambda function `get_lambda`
    - `GET /template-microservice/{template-microservice-key-1}` calling the lambda function `get_other_lambda` with a path parameter `{template-microservice-key-1}`
```json
{
    "template-microservice" : [
        {
            "path":"template-microservice",
            "methods_for_that_path":[
                {"method":"GET","lambda_fct":"get_lambda"}
            ],
            "children_resources":[
                {
                    "path":"{template-microservice-key-1}",
                    "methods_for_that_path":[
                        {"method":"GET","lambda_fct":"get_other_lambda"}
                    ],
                    "children_resources":[]
                }
            ]
        }        
    ]
}
```