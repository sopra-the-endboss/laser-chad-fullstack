The backend consists of small isolated microservices. To keep code duplication to a minimum and ensure a basic infrastrcture all services can use and rely on, there are some services that are deployed globally:
- API Gateway
- API Gateway ID sharing server
- Templates and functions for deployment
- Default Lambda handler for OPTIONS methods

# Choice and motivation for backend infracstructure
Since the primary goal of the project was to develop the application with a microservice oriented infrastructure suitable for the AWS cloud, the choice of using localstack for local cloud development is a given. For the single microservices, we followed the basic microservice structure proposed by AWS and localstack which include:
- An API Gateway to route HTTP requests coming from the frontend to the appropriate lambda handlers
- Lambda functions which contain the logic. They are triggered by the API Gateway, receive requests and return appropriate answers after manipulating data in the backend
- Dynamo DB as the primary data storage technology as a fast performing and scalable Key-Value store

We tried to keep the architecture simple and only use those services that were necessary to implement our features. This is why we relied on the lambda functions heavily to process and return all data from the backend to the frontend.

## Database and storage
At first, we also considered to use a traditional relational database like PostgreSQL or MySQL for the backend. After some discussion we settled for a more flexible DynamoDB approach, because the simple Key-Value store allowed us to develop the different microservices in parallel, using separate tables for all microservices. This decision obliged us however to communicate well about the common data structure so that there was consistency in the data model across services.
Another feature we initially planned, but did not (yet) implement is the usage of a S3 storage for static content. While this service could definitely be of use in the future, the current development up until the final submission did not necessitate it, hence this service was planned but in the end not actually used.


# Common infrastructure for all microservices

#### API Gateway
The API Gateway serves as the connection between the backend services and the frontend. The frontend must be able to make call to a URL to receive HTTP responses from the backend. The backend services must be able to register their functions on a given URL path. This is provided by the API Gateway. The service [apig-main](./apig-main/) creates an API Gateway, see the README for more information.

#### API Gateway ID sharing server
In order to make the generated URL available to the frontend service, a small Flask is deployed. Its sole job is to provide the URL generated by apig-main to the frontend. The frontend can then call the server and receives the URL on which it can make subsequent calls.  
This setup is neccesary since we can not provide a static URL which would require various pro features of localstack.

#### Templates
The folder [template-microservice](./template-microservice/) contains a template for a microservice with all neccesary configuraitons, labmda handlers, a deploy scirpt and a dockerfile. It also contains the following files that are used by all new microservice:
- [deploy_utils.py](./template-microservice/deploy_utils.py)
- [deploy.py](./template-microservice/deploy.py)

Those two scripts take care of the deployment of the specified resources (DynamoDB tables, Lambda functions, API routes etc).

#### Default Lambda handler for OPTIONS methods
During deployment we ran into CORS errors which blocked calls from the frontend to the backend. To enable CORS with API Gateway, each route must implement an OPTIONS method which sends the appropirate headers in a prefetch. (https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-cors.html). To reduce code duplication, the service [options_lambda_function](./options_lambda_function/) deploys a lambda handler which simply returns a 200 message and the appropirate CORS headers. This function is deployed once and used by all other microservices for each integrated route.

#### Tests
The backend tests are run in a CI pipeline with Github Actions. See the [github actions folder](../.github/workflows/code_quality.yml) for the concrete command and workflow. The produced [test report](../.qodana/code-coverage/) is updated and uploaded in the repo
If you want to run the test manually and generate an inline coverage report, run this from a terminal in the root directory:
`coverage run -m pytest && coverage report -m`

###### Test limitations
The current moto3 mocking framework for AWS does not support our API Gateway integration (AWS_PROXY), hence a proper intergation test with a mocked API Gateway with localstack is currently not possible. For more information see http://docs.getmoto.org/en/latest/docs/services/apigateway.html.


# Microservice structure
A microservice uses the templates and utils from the `template-microservice` folder as much as possible to standardize deployment and reduce duplication.  
Each microservice contains a `config` folder where the following files are located. The `deploy.py` script then refers to those configurations to deploy the desired microservice.

- `db_schema.json` A list of Dynamo table specifications that will be created upon deployment. It defines the name of the table and the keys of the table.
- `mock_data.json` If desired, any mock data that will be injected into the tables upon deployment. Can be empty.
- `request_models.json` Named request models in JSON schema draft 4, following the AWS specifications. Those schemas can be used to specify a valid body in the API calls made to the respective routes and lambda integrations. This is helpful to ensure the validity of the data coming from the frontend. The `title` attribute is then used in `resources_to_create.json` to specify which route and lambda integartion uses (if any) which request model.
- `request_validators.json` This is part of the validation, specifying which part of the request made to the API Gateway should be checked. In this project, the `bodyOnly` validator is used. This means headers and other parameters of the request are not validated, only the body of a request.
- `resources_to_create.json` A nested json of routes to create for the microservice. The nested levels build up the route. The following example would build the following to routes:  
    - `GET /template-microservice` calling the lambda function `get_lambda`
    - `GET /template-microservice/{template-microservice-key-1}` calling the lambda function `get_other_lambda` with a path parameter `{template-microservice-key-1}`
```json
{
    "template-microservice" : [
        {
            "path":"template-microservice",
            "methods_for_that_path":[
                {"method":"GET","lambda_fct":"get_lambda"}
            ],
            "children_resources":[
                {
                    "path":"{template-microservice-key-1}",
                    "methods_for_that_path":[
                        {"method":"GET","lambda_fct":"get_other_lambda"}
                    ],
                    "children_resources":[]
                }
            ]
        }        
    ]
}
```